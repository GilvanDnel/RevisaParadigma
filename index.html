<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz: Paradigmas de Programação</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .quiz-container {
            transition: opacity 0.5s ease-in-out;
        }
        .feedback-modal {
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        }
        .correct {
            background-color: #22c55e !important; /* green-500 */
            color: white !important;
            border-color: #16a34a !important; /* green-600 */
        }
        .incorrect {
            background-color: #ef4444 !important; /* red-500 */
            color: white !important;
            border-color: #dc2626 !important; /* red-600 */
        }
        .btn-option:disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center justify-center p-4">

    <div id="app" class="w-full max-w-2xl mx-auto mb-4">
        <div id="quiz-container" class="bg-gray-800 p-6 sm:p-8 rounded-2xl shadow-2xl border border-gray-700">
            <div id="header" class="mb-6">
                 <div class="flex justify-between items-center mb-2">
                    <h1 class="text-2xl sm:text-3xl font-bold text-cyan-400">Quiz de Paradigmas</h1>
                    <div id="score-counter" class="text-lg font-semibold bg-gray-700 px-3 py-1 rounded-lg">Pontos: 0</div>
                </div>
                <div id="progress-container" class="w-full bg-gray-700 rounded-full h-2.5">
                    <div id="progress-bar" class="bg-cyan-500 h-2.5 rounded-full" style="width: 0%"></div>
                </div>
                 <p id="question-counter" class="text-right text-sm text-gray-400 mt-2"></p>
            </div>
           
            <div id="question-area">
                <h2 id="question" class="text-xl font-semibold mb-6 min-h-[56px]">Carregando pergunta...</h2>
                <div id="answer-buttons" class="grid grid-cols-1 gap-4">
                    <!-- Buttons will be generated by JS -->
                </div>
            </div>

            <div class="mt-8 flex justify-end">
                <button id="next-btn" class="hidden bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-2 px-6 rounded-lg transition-all duration-300 shadow-lg">Próximo</button>
            </div>
        </div>
    </div>
    
    <!-- Feedback Modal -->
    <div id="feedback-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50">
        <div class="bg-gray-800 rounded-2xl p-8 max-w-lg w-full border border-gray-700 shadow-2xl transform scale-95">
            <h3 id="feedback-title" class="text-2xl font-bold mb-4"></h3>
            <p id="feedback-explanation" class="text-gray-300 mb-4"></p>
            <div class="bg-gray-900 p-4 rounded-lg">
                <h4 class="font-semibold text-cyan-400 mb-2">Analogia do Dia a Dia:</h4>
                <p id="feedback-analogy" class="text-gray-400"></p>
            </div>
            <button id="close-modal-btn" class="mt-6 w-full bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-2 px-4 rounded-lg transition-all duration-300">Entendi</button>
        </div>
    </div>
    
    <footer class="w-full text-center text-gray-500 text-sm mt-4">
        Criado por Gilvan Daniel da Silva
    </footer>

    <script>
        const questions = [
            // ========== PDF 1: ensinc1.pdf (Introdução) ==========
            {
                question: "O que é um paradigma de programação?",
                answers: [
                    { text: "Uma linguagem de programação específica como Python ou Java.", correct: false },
                    { text: "Um modelo ou metodologia para estruturar e resolver problemas com código.", correct: true },
                    { text: "Um conjunto de bibliotecas para desenvolvimento de software.", correct: false },
                    { text: "Um software para escrever e compilar código (IDE).", correct: false }
                ],
                explanation: "Um paradigma de programação não é uma linguagem, mas sim uma forma de classificar as linguagens segundo sua metodologia e a forma como estruturam a solução de problemas.",
                analogyCorrect: "Pense em cozinhar. O paradigma é o 'estilo' da cozinha (italiana, japonesa, etc.), enquanto a linguagem seria uma 'receita' específica dentro desse estilo. O paradigma guia a forma de pensar.",
                analogyIncorrect: "Um paradigma é como uma planta de uma casa. Ele define a estrutura (onde fica a cozinha, os quartos), mas não os materiais exatos (a linguagem). A pergunta era sobre o plano geral, não os 'tijolos'."
            },
            {
                question: "Qual paradigma de programação é dividido em Lógico e Funcional?",
                answers: [
                    { text: "Imperativo", correct: false },
                    { text: "Orientado a Objetos", correct: false },
                    { text: "Declarativo", correct: true },
                    { text: "Procedimental", correct: false }
                ],
                explanation: "O paradigma Declarativo se divide em Funcional (baseado em funções matemáticas) e Lógico (baseado em fatos e regras lógicas). Ele foca em 'o que' fazer, não em 'como'.",
                analogyCorrect: "No paradigma declarativo, você age como um chefe: diz 'quero um relatório de vendas' (o que quer). Você não detalha como buscar os dados no banco, formatar, etc. (o como fazer).",
                analogyIncorrect: "Imagine pedir um café. No modo declarativo, você diz 'um café, por favor'. No imperativo, você daria as instruções: 'pegue o pó, coloque no filtro, ferva a água...'. A pergunta era sobre o primeiro estilo."
            },
            {
                question: "Qual foi a primeira linguagem a introduzir o conceito de classes, sendo um marco para a programação orientada a objetos?",
                answers: [
                    { text: "C", correct: false },
                    { text: "Pascal", correct: false },
                    { text: "Simula", correct: true },
                    { text: "Java", correct: false }
                ],
                explanation: "Desenvolvida nos anos 1960, Simula foi a primeira linguagem a introduzir o conceito de classes, que é a base da Programação Orientada a Objetos (POO).",
                analogyCorrect: "Simula foi como o primeiro inventor que pensou em agrupar todas as peças de um relógio (dados e funções) em uma única 'caixa' (classe), em vez de deixá-las espalhadas. Essa ideia mudou tudo.",
                analogyIncorrect: "Pense na evolução dos telefones. Simula foi como o primeiro protótipo de um celular, que introduziu a ideia de mobilidade. Linguagens como Java e C++ foram os smartphones que popularizaram e aprimoraram essa ideia original."
            },
            {
                question: "A programação Orientada a Eventos segue o 'Princípio de Hollywood'. O que isso significa?",
                answers: [
                    { text: "O código deve ser glamoroso e bem escrito.", correct: false },
                    { text: "'Não nos ligue, nós ligaremos para você.' O sistema reage a eventos.", correct: true },
                    { text: "Todo programa deve ter um final feliz.", correct: false },
                    { text: "Apenas os melhores programadores podem usá-lo.", correct: false }
                ],
                explanation: "O 'Princípio de Hollywood' significa que o fluxo do programa não é controlado por uma sequência de chamadas, mas sim pelo sistema que 'chama' seu código em resposta a eventos (clique do mouse, tecla pressionada).",
                analogyCorrect: "É como se inscrever para um teste de elenco. Você deixa seu contato e espera. Você não fica ligando para o estúdio (seu código chamando o sistema). O estúdio liga para você quando uma vaga aparece (o sistema chama seu código quando um evento ocorre).",
                analogyIncorrect: "Imagine um alarme de incêndio. Ele fica em silêncio até que um evento (fumaça) o acione. Ele não pergunta a cada segundo 'há fumaça?'. Ele reage quando o evento acontece. É assim que a programação orientada a eventos funciona."
            },
            {
                question: "Linguagens como C, C++ e Java, que consistem em uma lista de instruções executadas uma de cada vez, pertencem a qual sub-paradigma do Imperativo?",
                answers: [
                    { text: "Funcional", correct: false },
                    { text: "Lógico", correct: false },
                    { text: "Procedimental", correct: true },
                    { text: "Orientado a Eventos", correct: false }
                ],
                explanation: "A programação Procedimental (ou Procedural) é um tipo de programação imperativa onde o programa é construído a partir de uma ou mais 'procedures' (procedimentos), também conhecidas como rotinas ou funções.",
                analogyCorrect: "É como seguir uma receita de bolo, passo a passo, na ordem exata em que está escrita. Você não pula do passo 1 para o 5. A ordem e a sequência de comandos são fundamentais.",
                analogyIncorrect: "Pense em montar um móvel da IKEA. Você segue o manual de instruções (o programa) em uma sequência rígida de passos (comandos procedimentais) para chegar ao resultado final."
            },
            {
                question: "Qual das seguintes características NÃO é essencial para uma linguagem de programação, de acordo com o material?",
                answers: [
                    { text: "Sintaxe e semântica bem definidas.", correct: false },
                    { text: "Ser a mais popular do mercado.", correct: true },
                    { text: "Ser implementável com eficiência aceitável.", correct: false },
                    { text: "Ser universal (capaz de expressar todo problema computável).", correct: false }
                ],
                explanation: "Popularidade é uma consequência de vários fatores, mas não um requisito técnico fundamental. Os outros itens (sintaxe/semântica, implementabilidade e universalidade) são essenciais para a definição de uma linguagem de programação.",
                analogyCorrect: "Uma ferramenta não precisa ser a mais vendida para ser boa. O importante é que ela funcione bem (eficiência), tenha um manual claro (sintaxe/semântica) e seja versátil (universal).",
                analogyIncorrect: "Pense em um carro. Para ser um carro, ele precisa de motor, rodas e direção (características essenciais). Não é obrigatório que ele seja o modelo mais vendido do ano."
            },
            {
                question: "O paradigma Lógico é baseado em fatos e regras. Qual linguagem é o exemplo mais clássico desse paradigma?",
                answers: [
                    { text: "C#", correct: false },
                    { text: "Prolog", correct: true },
                    { text: "JavaScript", correct: false },
                    { text: "Ruby", correct: false }
                ],
                explanation: "Prolog é a linguagem canônica do paradigma lógico. Nela, você fornece uma base de conhecimento (fatos e regras) e faz perguntas, e o sistema usa a lógica para deduzir as respostas.",
                analogyCorrect: "Usar Prolog é como ser o Sherlock Holmes. Você dá a ele todas as pistas (fatos) e as regras de dedução ('se A, então B'), e ele conecta os pontos para resolver o mistério (responder sua pergunta).",
                analogyIncorrect: "É como um sistema de genealogia. Você informa que 'João é pai de Ana' e 'Ana é mãe de Pedro' (fatos). Depois, você pergunta 'João é avô de Pedro?' e o sistema usa as regras de parentesco para responder 'Sim'."
            },
            {
                question: "O paradigma Funcional, usado por linguagens como Haskell, tem sua base em qual área do conhecimento?",
                answers: [
                    { text: "Engenharia Civil", correct: false },
                    { text: "Filosofia", correct: false },
                    { text: "Matemática", correct: true },
                    { text: "Biologia", correct: false }
                ],
                explanation: "O paradigma de programação funcional se origina diretamente do processamento de funções matemáticas, tratando a computação como a avaliação de funções e evitando a alteração de estado e dados mutáveis.",
                analogyCorrect: "Programar em estilo funcional é como usar uma calculadora científica. Você aplica funções (soma, seno, etc.) a valores para obter um resultado. Você não 'muda' o número 5 para 7, você aplica a função 'somar 2' ao 5.",
                analogyIncorrect: "Pense em uma linha de montagem. Cada estação é uma função que recebe algo, transforma e passa para a próxima. A peça original não é alterada, mas sim transformada em cada etapa até o produto final."
            },
            {
                question: "Qual o principal foco do paradigma imperativo?",
                answers: [
                    { text: "A definição de funções puras que evitam efeitos colaterais.", correct: false },
                    { text: "A descrição de como o programa deve executar, alterando o estado da máquina passo a passo.", correct: true },
                    { text: "A representação do conhecimento através de fatos e regras lógicas.", correct: false },
                    { text: "A modelagem de objetos do mundo real com atributos e comportamentos.", correct: false }
                ],
                explanation: "O paradigma imperativo descreve a computação em termos de um estado do programa e de comandos que mudam esse estado. O foco está na sequência de comandos (o 'como fazer').",
                analogyCorrect: "É como dar instruções de GPS para alguém: 'vire à direita, siga por 200 metros, vire à esquerda'. Você está dando comandos explícitos, passo a passo, que alteram a posição (estado) da pessoa.",
                analogyIncorrect: "Se o paradigma declarativo é dizer o destino, o imperativo é ditar cada curva do caminho. Você comanda o processo, não apenas declara o objetivo."
            },
            {
                question: "A ascensão da internet nos anos 1990 impulsionou o desenvolvimento de novas linguagens. Qual das linguagens abaixo NÃO é um exemplo desse período citado no material?",
                answers: [
                    { text: "Java", correct: false },
                    { text: "JavaScript", correct: false },
                    { text: "PHP", correct: false },
                    { text: "C++", correct: true }
                ],
                explanation: "C++ foi criada nos anos 1980, como uma extensão de C. Java, JavaScript e PHP surgiram e/ou se popularizaram nos anos 1990, fortemente influenciadas pela necessidade de desenvolvimento para a web.",
                analogyCorrect: "C++ é como o rock clássico dos anos 80. Java, JS e PHP são como os gêneros musicais que explodiram nos anos 90 com a MTV e a globalização, cada um atendendo a um novo público (a web).",
                analogyIncorrect: "Pense em ferramentas. C++ é uma chave de boca robusta e versátil que já existia. Com a chegada de um novo tipo de parafuso (a web), surgiram novas ferramentas especializadas como Java, JS e PHP."
            },

            // ========== PDF 2: enisinc2.pdf (Imperativo) ==========
            {
                question: "Qual conceito é fundamental na arquitetura de von Neumann e no paradigma imperativo, significando que o valor antigo de uma variável é destruído ao se atribuir um novo?",
                answers: [
                    { text: "Atribuição destrutiva", correct: true },
                    { text: "Avaliação curto-circuito", correct: false },
                    { text: "Abstração de processo", correct: false },
                    { text: "Tipagem recursiva", correct: false }
                ],
                explanation: "A atribuição destrutiva é a característica central do paradigma imperativo, onde a memória (variável) é alterada, e seu conteúdo anterior é perdido permanentemente ao receber um novo valor.",
                analogyCorrect: "É como escrever em um quadro branco. Se você escreve 'maçã' e depois apaga para escrever 'laranja', a palavra 'maçã' desapareceu para sempre. O novo valor destruiu o antigo.",
                analogyIncorrect: "Pense em uma vaga de estacionamento. Quando um carro sai e outro entra, o carro anterior não está mais lá. A vaga (variável) agora contém um novo carro (valor)."
            },
            {
                question: "Em linguagens imperativas, qual comando permite a transferência incondicional do fluxo de execução para um ponto específico do código, sendo hoje considerado uma má prática?",
                answers: [
                    { text: "if-else", correct: false },
                    { text: "while", correct: false },
                    { text: "for", correct: false },
                    { text: "goto", correct: true }
                ],
                explanation: "O comando 'goto' (desvio incondicional) permite saltar para qualquer rótulo no código, quebrando a estrutura sequencial. Seu uso indiscriminado gera o chamado 'código espaguete', difícil de ler e manter.",
                analogyCorrect: "Usar 'goto' é como estar lendo um livro e encontrar uma instrução: 'agora pule para a página 97'. Se houver muitas dessas, a história fica confusa e sem nexo, um verdadeiro 'livro espaguete'.",
                analogyIncorrect: "Imagine seguir uma trilha com placas. Os comandos 'if' e 'while' são bifurcações sinalizadas. O 'goto' é como sair da trilha e cortar pelo meio do mato para um ponto aleatório. Pode até chegar mais rápido, mas é perigoso e bagunça o caminho."
            },
            {
                question: "Qual é a principal diferença entre uma função e um procedimento no paradigma imperativo?",
                answers: [
                    { text: "Funções usam parâmetros, procedimentos não.", correct: false },
                    { text: "Uma função sempre retorna um valor, enquanto um procedimento (ou função 'void') executa ações sem retornar um valor.", correct: true },
                    { text: "Procedimentos são mais rápidos que funções.", correct: false },
                    { text: "Funções só podem ser usadas em linguagens funcionais.", correct: false }
                ],
                explanation: "A distinção clássica é que uma função computa e retorna um valor (ex: `calcularArea()`), que pode ser usado em uma expressão. Um procedimento executa uma série de comandos para alterar o estado do programa (ex: `imprimirRelatorio()`) e não retorna um valor (em C/Java, isso é representado pelo tipo de retorno `void`).",
                analogyCorrect: "Uma função é como perguntar a alguém 'quanto é 2+2?'. A pessoa responde '4' (retorna um valor). Um procedimento é como pedir a essa pessoa 'apague a luz'. Ela executa a ação, mas não te 'retorna' nada.",
                analogyIncorrect: "Pense em uma máquina de vendas. A função é o botão que você aperta para pegar um refrigerante (ele te retorna um produto). O procedimento é o técnico que vem consertar a máquina (ele realiza uma ação, mas não te entrega um item)."
            },
            {
                question: "O que é avaliação 'curto-circuito' em expressões booleanas?",
                answers: [
                    { text: "Um erro que causa uma falha elétrica no computador.", correct: false },
                    { text: "O resultado da expressão é determinado sem avaliar todos os operandos.", correct: true },
                    { text: "A expressão é avaliada duas vezes para garantir o resultado.", correct: false },
                    { text: "O código é otimizado para usar menos memória.", correct: false }
                ],
                explanation: "Na expressão `(A && B)`, se `A` for falso, o resultado total já é falso, e `B` não precisa ser avaliado. Da mesma forma, em `(A || B)`, se `A` for verdadeiro, o resultado total já é verdadeiro, e `B` não é avaliado. Isso é o curto-circuito.",
                analogyCorrect: "Você precisa de duas chaves para abrir uma porta (A e B). Se você tenta a chave A e ela não serve (falso), você nem se dá ao trabalho de testar a chave B. Você já sabe que a porta não vai abrir. Isso é um curto-circuito.",
                analogyIncorrect: "Imagine que para ser contratado você precisa ter diploma (A) E falar inglês (B). Durante a entrevista, se você diz que não tem diploma, o entrevistador nem pergunta sobre seu inglês. O processo foi 'curto-circuitado'."
            },
            {
                question: "Na expressão `a + b * c`, qual operação é realizada primeiro na maioria das linguagens imperativas devido às regras de precedência?",
                answers: [
                    { text: "a + b", correct: false },
                    { text: "b * c", correct: true },
                    { text: "A avaliação é da esquerda para a direita, sempre.", correct: false },
                    { text: "O programador pode escolher a ordem.", correct: false }
                ],
                explanation: "A maioria das linguagens segue a ordem de precedência matemática padrão, onde a multiplicação (*) e a divisão (/) têm maior precedência do que a adição (+) e a subtração (-).",
                analogyCorrect: "É a mesma regra que aprendemos na escola na matéria de matemática. Em uma conta, multiplicações e divisões são resolvidas antes de somas e subtrações, a menos que haja parênteses.",
                analogyIncorrect: "Pense em se arrumar. Você primeiro veste as meias e depois os sapatos, não o contrário. Existe uma ordem de precedência natural, assim como nos operadores matemáticos."
            },
            {
                question: "Comandos como `for` e `while` são usados para qual propósito?",
                answers: [
                    { text: "Seleção condicional de código (executar um bloco ou outro).", correct: false },
                    { text: "Declaração de variáveis e tipos de dados.", correct: false },
                    { text: "Execução repetida de um bloco de código (iteração).", correct: true },
                    { text: "Chamada de funções e procedimentos.", correct: false }
                ],
                explanation: "Comandos iterativos (`for`, `while`, `do-while`) são usados para criar laços (loops) que repetem a execução de um conjunto de instruções enquanto uma condição for verdadeira ou por um número predefinido de vezes.",
                analogyCorrect: "É como dar voltas em uma pista de corrida. O `while` seria 'continue correndo enquanto você não estiver cansado'. O `for` seria 'dê exatamente 10 voltas na pista'. Ambos servem para repetir a ação de 'correr'.",
                analogyIncorrect: "Pense em carimbar uma pilha de 100 documentos. Você não cria uma instrução para cada documento. Você cria um laço `for` que diz: 'para cada documento de 1 a 100, execute a ação de carimbar'."
            },
            {
                question: "Qual dos seguintes é um exemplo de 'Tipo Composto'?",
                answers: [
                    { text: "Inteiro (int)", correct: false },
                    { text: "Booleano (boolean)", correct: false },
                    { text: "Estrutura/Registro (struct)", correct: true },
                    { text: "Caractere (char)", correct: false }
                ],
                explanation: "Tipos primitivos (int, boolean, char) são atômicos e não podem ser subdivididos. Tipos compostos, como `struct` em C ou `record` em Pascal, agrupam diferentes tipos de dados em uma única unidade (ex: um 'empregado' com nome, idade e salário).",
                analogyCorrect: "Um tipo primitivo é como um tijolo. Um tipo composto é a parede inteira, que é feita de vários tijolos (e cimento). É uma estrutura que agrupa elementos menores.",
                analogyIncorrect: "Pense em uma ficha de cadastro. Nela você tem campos para nome (texto), idade (número) e se é assinante (booleano). A ficha inteira, com todos esses campos juntos, representa um tipo composto."
            },
            {
                question: "Em C, os operadores de incremento `++cont` (pré-fixado) e `cont++` (pós-fixado) têm uma diferença sutil. Qual é?",
                answers: [
                    { text: "Não há diferença, ambos incrementam a variável.", correct: false },
                    { text: "Um é para inteiros, o outro para 'floats'.", correct: false },
                    { text: "`++cont` incrementa antes de usar o valor na expressão; `cont++` incrementa depois.", correct: true },
                    { text: "`cont++` é mais rápido que `++cont`.", correct: false }
                ],
                explanation: "Na expressão `soma = ++cont;`, primeiro `cont` é incrementado e depois seu novo valor é atribuído a `soma`. Em `soma = cont++;`, primeiro o valor original de `cont` é atribuído a `soma`, e só então `cont` é incrementado.",
                analogyCorrect: "Pense em pegar um doce de um pote. `++cont` (pré-fixado) é 'primeiro coloque mais um doce no pote, depois me diga quantos doces têm'. `cont++` (pós-fixado) é 'primeiro me diga quantos doces têm, depois coloque mais um doce no pote'.",
                analogyIncorrect: "Imagine uma fila. `++cont` é 'uma pessoa entra na fila, depois contamos o total'. `cont++` é 'contamos o total, depois uma pessoa entra na fila'. O momento do incremento muda em relação à avaliação da expressão."
            },
            {
                question: "O que é um 'overflow' em uma expressão?",
                answers: [
                    { text: "Quando o código flui de uma função para outra.", correct: false },
                    { text: "Um erro de divisão por zero.", correct: false },
                    { text: "O resultado de uma operação é grande demais para ser armazenado na variável.", correct: true },
                    { text: "Um laço que executa mais vezes do que o esperado.", correct: false }
                ],
                explanation: "Overflow (transbordamento) ocorre quando o resultado de uma operação aritmética excede o valor máximo que o tipo da variável pode representar, causando um resultado incorreto ou um erro.",
                analogyCorrect: "É como tentar colocar 2 litros de água em uma garrafa de 1 litro. A água vai transbordar porque não há espaço suficiente. A garrafa é a variável, e a água é o resultado do cálculo.",
                analogyIncorrect: "Pense no hodômetro de um carro antigo que só vai até 99.999 km. Quando ele atinge esse valor e anda mais 1 km, ele zera. O resultado 'transbordou' a capacidade de representação do aparelho."
            },
            {
                question: "O comando `switch` é uma forma de qual tipo de estrutura de controle?",
                answers: [
                    { text: "Seleção n-direcional", correct: true },
                    { text: "Iteração pré-estabelecida", correct: false },
                    { text: "Desvio incondicional", correct: false },
                    { text: "Iteração indefinida", correct: false }
                ],
                explanation: "O `switch` (ou `case`) é um comando condicional n-direcional, pois permite escolher entre múltiplos caminhos (casos) de execução com base no valor de uma única variável, ao contrário do `if-else` que é bidirecional.",
                analogyCorrect: "É como um menu de atendimento telefônico: 'Disque 1 para vendas, 2 para suporte, 3 para financeiro...'. Você escolhe um entre vários caminhos possíveis com base na sua entrada.",
                analogyIncorrect: "Pense em um cruzamento com várias ruas. O `if-else` é uma simples esquina onde você vira à direita ou à esquerda. O `switch` é uma rotatória com múltiplas saídas, e você escolhe qual pegar."
            },

            // ========== PDF 3: ensinc3.pdf (Orientado a Objetos) ==========
            {
                question: "Qual é a principal diferença entre um compilador e um interpretador?",
                answers: [
                    { text: "Compiladores são para Windows, interpretadores para Linux.", correct: false },
                    { text: "Compilador traduz todo o código de uma vez antes da execução; interpretador traduz e executa linha por linha.", correct: true },
                    { text: "Compiladores são usados em POO, interpretadores em programação procedural.", correct: false },
                    { text: "Não há diferença funcional, apenas o nome muda.", correct: false }
                ],
                explanation: "Um compilador (como o de C++) analisa o código-fonte inteiro e o traduz para código de máquina, criando um arquivo executável. Um interpretador (como o de Python) lê o código uma instrução de cada vez, traduz e a executa imediatamente.",
                analogyCorrect: "Um compilador é como um tradutor de livros: ele pega o livro inteiro em inglês, traduz para português, e só depois você pode ler o livro traduzido. Um interpretador é como um tradutor simultâneo em uma palestra: ele ouve uma frase, traduz e fala para você, frase por frase.",
                analogyIncorrect: "Imagine preparar um discurso. O compilador é escrever o discurso completo e depois lê-lo. O interpretador é falar de improviso, pensando em cada frase no momento em que a diz."
            },
            {
                question: "Em POO, o que é um 'construtor'?",
                answers: [
                    { text: "Uma função que destrói um objeto para liberar memória.", correct: false },
                    { text: "Um método especial chamado automaticamente quando um objeto é criado (instanciado).", correct: true },
                    { text: "Uma variável que armazena o endereço de memória de um objeto.", correct: false },
                    { text: "O processo de converter um tipo de dado em outro.", correct: false }
                ],
                explanation: "O construtor é um método com o mesmo nome da classe (em muitas linguagens) que é executado no momento da criação de um objeto. Sua função é inicializar os atributos do objeto, garantindo que ele comece em um estado válido.",
                analogyCorrect: "O construtor é como a linha de montagem de um carro. Quando um novo carro (objeto) é criado, o construtor é responsável por colocar o motor, as rodas e a pintura (inicializar os atributos), garantindo que ele saia pronto para uso.",
                analogyIncorrect: "Pense em um formulário de cadastro. O construtor é a regra que diz que todo novo usuário (objeto) deve começar com um nome e um e-mail definidos. Ele garante a configuração inicial."
            },
            {
                question: "O que significa 'polimorfismo' em Programação Orientada a Objetos?",
                answers: [
                    { text: "A herança de atributos de múltiplas classes.", correct: false },
                    { text: "Ocultar a complexidade interna de um objeto.", correct: false },
                    { text: "A capacidade de objetos de classes diferentes responderem à mesma mensagem (método) de maneiras específicas.", correct: true },
                    { text: "A criação de um modelo ou 'molde' para objetos.", correct: false }
                ],
                explanation: "Polimorfismo (muitas formas) permite que um método com o mesmo nome tenha comportamentos diferentes em classes diferentes (geralmente ligadas por herança). Por exemplo, um método `emitirSom()` pode ser executado de forma diferente por um objeto `Cachorro` e um objeto `Gato`.",
                analogyCorrect: "Pense no botão 'play' de um controle remoto universal. A mesma mensagem ('play') causa ações diferentes dependendo do aparelho: na TV, mostra um filme; no som, toca uma música; no videogame, inicia um jogo.",
                analogyIncorrect: "Imagine pedir para diferentes animais 'falar'. Um cachorro vai latir, um gato vai miar, um pato vai grasnar. A mensagem é a mesma ('falar'), mas a resposta (o comportamento) é diferente para cada tipo de animal (classe)."
            },
            {
                question: "Se uma linguagem como Python não exige que o tipo de uma variável seja declarado explicitamente, ela é considerada:",
                answers: [
                    { text: "Fortemente tipada", correct: false },
                    { text: "Compilada", correct: false },
                    { text: "Fracamente tipada / Com tipagem dinâmica", correct: true },
                    { text: "Orientada a objetos puros", correct: false }
                ],
                explanation: "Linguagens com tipagem dinâmica (ou fracamente tipadas, em alguns contextos) permitem que o tipo de uma variável seja determinado em tempo de execução. Em Python, você pode fazer `x = 10` e depois `x = 'texto'` sem erro, pois o tipo é associado ao valor, não à variável.",
                analogyCorrect: "É como uma caixa de armazenamento sem etiqueta. Você pode guardar livros nela hoje e sapatos amanhã. A caixa (variável) se adapta ao conteúdo (valor) que você coloca dentro dela. Uma linguagem fortemente tipada seria uma caixa etiquetada 'Apenas Livros'.",
                analogyIncorrect: "Pense em um copo. Em uma linguagem com tipagem dinâmica, o mesmo copo pode conter água, depois suco, depois refrigerante. Em uma linguagem com tipagem estática (forte), você teria um copo específico para cada tipo de bebida."
            },
            {
                question: "Qual pilar da POO é responsável por agrupar dados e métodos em uma classe, escondendo os detalhes internos e protegendo os dados?",
                answers: [
                    { text: "Herança", correct: false },
                    { text: "Encapsulamento", correct: true },
                    { text: "Polimorfismo", correct: false },
                    { text: "Instanciação", correct: false }
                ],
                explanation: "Encapsulamento é a prática de proteger os atributos de uma classe (geralmente com `private`) e fornecer métodos públicos (`getters` e `setters`) para acessá-los de forma controlada. Isso evita modificações diretas e indevidas no estado do objeto.",
                analogyCorrect: "É como uma pílula de remédio. O plástico (a classe) encapsula o pó químico (os dados). Você não interage diretamente com o pó; você apenas engole a pílula (usa a interface pública do objeto).",
                analogyIncorrect: "Pense no motor de um carro. Ele está dentro do capô (encapsulado). Você, como motorista, não manipula os pistões diretamente. Você usa o acelerador e a chave de ignição (a interface pública) para interagir com ele de forma segura."
            },
            {
                question: "Quando dizemos que `cachorro` é uma 'instância' da classe `Mamifero`, o que isso significa?",
                answers: [
                    { text: "`cachorro` é uma cópia exata da classe `Mamifero`.", correct: false },
                    { text: "`cachorro` é um objeto concreto criado a partir do molde da classe `Mamifero`.", correct: true },
                    { text: "`cachorro` é uma outra palavra para 'método'.", correct: false },
                    { text: "`cachorro` é uma classe que herda de `Mamifero`.", correct: false }
                ],
                explanation: "Uma classe é um molde (um projeto). Uma instância é um objeto real construído a partir desse molde. O ato de criar um objeto a partir de uma classe é chamado de 'instanciação'.",
                analogyCorrect: "A classe `Mamifero` é a planta de uma casa. Uma instância (`cachorro`) é uma casa real construída seguindo essa planta. Você pode construir várias casas (instâncias) a partir da mesma planta (classe).",
                analogyIncorrect: "A classe é a forma de biscoitos. As instâncias são os biscoitos que você faz usando essa forma. Cada biscoito é um objeto individual, mas todos seguem o mesmo modelo."
            },
            {
                question: "O que é um Tipo Abstrato de Dados (TAD)?",
                answers: [
                    { text: "Um tipo de dado que só existe na teoria e não pode ser programado.", correct: false },
                    { text: "Um agrupamento de dados (atributos) junto com as operações (métodos) que os manipulam.", correct: true },
                    { text: "Um tipo de dado primitivo, como `int` ou `char`.", correct: false },
                    { text: "Uma técnica para escrever código mais rápido.", correct: false }
                ],
                explanation: "Um TAD é um modelo matemático para tipos de dados onde o foco está no comportamento (operações) e não na implementação. As classes em POO são uma forma de implementar TADs, encapsulando dados e as operações sobre eles.",
                analogyCorrect: "Pense no conceito de 'Lista'. Você sabe o que pode fazer com ela: adicionar item, remover item, ver o tamanho. Isso é o TAD. A forma como ela é implementada por baixo dos panos (com arrays ou ponteiros) é um detalhe que o TAD esconde.",
                analogyIncorrect: "Um TAD é como o painel de um micro-ondas. Ele te oferece as operações ('descongelar', 'pipoca', 'ajustar tempo'), mas esconde como as micro-ondas são geradas e aquecem a comida. Ele define 'o que' faz, não 'como' faz."
            },
            {
                question: "Se a classe `Carro` herda da classe `Veiculo`, e a classe `VeiculoEletrico` herda de `Carro`, que tipo de herança é essa?",
                answers: [
                    { text: "Herança Múltipla", correct: false },
                    { text: "Herança Simples (em múltiplos níveis)", correct: true },
                    { text: "Herança Híbrida", correct: false },
                    { text: "Não é um exemplo de herança.", correct: false }
                ],
                explanation: "Herança simples ocorre quando uma classe herda de apenas uma outra classe. Isso pode ocorrer em vários níveis, criando uma hierarquia (como avô -> pai -> filho), mas cada classe na cadeia tem apenas um 'pai' direto.",
                analogyCorrect: "É como uma linhagem familiar: seu pai herdou características do seu avô, e você herdou características do seu pai. Cada um tem apenas um pai direto, formando uma cadeia de herança simples.",
                analogyIncorrect: "Pense em pastas no computador. A pasta `Documentos` está dentro de `Usuários`, que está dentro de `C:`. É uma hierarquia, mas cada pasta tem apenas um contêiner pai direto."
            },
            {
                question: "Em C#, o que é um 'delegate' no contexto da programação orientada a eventos?",
                answers: [
                    { text: "É o nome dado a um evento específico, como um clique.", correct: false },
                    { text: "É um tipo que representa uma referência a métodos com uma assinatura específica, funcionando como um 'contrato' para um manipulador de eventos.", correct: true },
                    { text: "É uma variável que armazena o último evento ocorrido.", correct: false },
                    { text: "É uma forma de deletar um objeto da memória.", correct: false }
                ],
                explanation: "Um 'delegate' em C# é um tipo de referência segura a um método. Em eventos, ele define a 'assinatura' que um método precisa ter para poder se inscrever e tratar aquele evento. Ele age como um intermediário entre quem dispara o evento e quem o escuta.",
                analogyCorrect: "Um 'delegate' é como um tipo específico de tomada. Ele define que só plugues de três pinos (métodos com a assinatura correta) podem se conectar ali. O evento é a eletricidade, e o método é o aparelho que será ligado.",
                analogyIncorrect: "Pense em um contrato para um serviço. O contrato (delegate) especifica o que o prestador (método) precisa fazer. Qualquer prestador que assine e cumpra esse contrato pode realizar o serviço quando for chamado (quando o evento ocorrer)."
            },
            {
                question: "Qual das opções abaixo melhor descreve o objetivo de usar 'get' e 'set' em C# ou outras linguagens de POO?",
                answers: [
                    { text: "Para tornar o código mais longo e complexo.", correct: false },
                    { text: "Para controlar o acesso e a modificação dos atributos de uma classe, permitindo validações.", correct: true },
                    { text: "São os únicos meios de declarar uma variável.", correct: false },
                    { text: "Para substituir o uso de construtores.", correct: false }
                ],
                explanation: "Métodos 'get' (acessores) e 'set' (modificadores) são a personificação do encapsulamento. Eles permitem que você leia (`get`) e escreva (`set`) em um atributo privado, mas com a possibilidade de adicionar lógica no meio, como validar se um valor é positivo antes de atribuí-lo.",
                analogyCorrect: "É como o caixa de um banco. Você não pode simplesmente entrar no cofre (atributo privado) e pegar dinheiro. Você precisa ir ao caixa ('setter'), pedir o valor, e ele fará as verificações necessárias antes de te entregar o dinheiro ('getter').",
                analogyIncorrect: "Pense no termostato de um ar condicionado. Você usa os botões ('setter') para definir a temperatura desejada, e o aparelho valida se está dentro do limite (ex: entre 18°C e 30°C). O display mostra a temperatura atual ('getter'). Você não manipula o motor diretamente."
            }
        ];

        // Element references
        const questionElement = document.getElementById('question');
        const answerButtonsElement = document.getElementById('answer-buttons');
        const nextButton = document.getElementById('next-btn');
        const feedbackModal = document.getElementById('feedback-modal');
        const feedbackTitle = document.getElementById('feedback-title');
        const feedbackExplanation = document.getElementById('feedback-explanation');
        const feedbackAnalogy = document.getElementById('feedback-analogy');
        const closeModalButton = document.getElementById('close-modal-btn');
        const scoreCounter = document.getElementById('score-counter');
        const questionCounter = document.getElementById('question-counter');
        const progressBar = document.getElementById('progress-bar');
        const quizContainer = document.getElementById('quiz-container');

        let currentQuestionIndex = 0;
        let score = 0;

        function shuffleQuestions(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function startQuiz() {
            shuffleQuestions(questions);
            currentQuestionIndex = 0;
            score = 0;
            scoreCounter.innerText = `Pontos: 0`;
            nextButton.classList.add('hidden');
            showQuestion();
        }

        function showQuestion() {
            resetState();
            let currentQuestion = questions[currentQuestionIndex];
            let questionNo = currentQuestionIndex + 1;
            questionElement.innerText = `${currentQuestion.question}`;
            questionCounter.innerText = `Pergunta ${questionNo} de ${questions.length}`;
            
            const progressPercentage = (questionNo / questions.length) * 100;
            progressBar.style.width = `${progressPercentage}%`;

            currentQuestion.answers.forEach(answer => {
                const button = document.createElement('button');
                button.innerHTML = answer.text;
                button.classList.add('btn-option', 'w-full', 'text-left', 'p-4', 'rounded-lg', 'border-2', 'border-gray-600', 'bg-gray-700', 'hover:bg-gray-600', 'hover:border-cyan-500', 'transition-all', 'duration-200');
                answerButtonsElement.appendChild(button);
                if (answer.correct) {
                    button.dataset.correct = answer.correct;
                }
                button.addEventListener('click', selectAnswer);
            });
        }

        function resetState() {
            nextButton.classList.add('hidden');
            while (answerButtonsElement.firstChild) {
                answerButtonsElement.removeChild(answerButtonsElement.firstChild);
            }
        }

        function selectAnswer(e) {
            const selectedBtn = e.target;
            const isCorrect = selectedBtn.dataset.correct === "true";
            
            if(isCorrect) {
                score++;
                scoreCounter.innerText = `Pontos: ${score}`;
                selectedBtn.classList.add('correct');
                showFeedback(true);
            } else {
                selectedBtn.classList.add('incorrect');
                showFeedback(false);
            }

            Array.from(answerButtonsElement.children).forEach(button => {
                if (button.dataset.correct === "true") {
                    if (!isCorrect) button.classList.add('correct');
                }
                button.disabled = true;
            });
            nextButton.classList.remove('hidden');
        }
        
        function showFeedback(isCorrect) {
            const currentQuestion = questions[currentQuestionIndex];
            if (isCorrect) {
                feedbackTitle.innerText = '✅ Parabéns, você acertou!';
                feedbackTitle.className = 'text-2xl font-bold mb-4 text-green-400';
                feedbackExplanation.innerText = currentQuestion.explanation;
                feedbackAnalogy.innerText = currentQuestion.analogyCorrect;
            } else {
                feedbackTitle.innerText = '❌ Ops, não foi desta vez!';
                feedbackTitle.className = 'text-2xl font-bold mb-4 text-red-400';
                feedbackExplanation.innerText = currentQuestion.explanation;
                feedbackAnalogy.innerText = currentQuestion.analogyIncorrect;
            }
            feedbackModal.classList.remove('hidden');
            feedbackModal.querySelector('div').classList.remove('scale-95');
            feedbackModal.querySelector('div').classList.add('scale-100');
        }

        function hideFeedback() {
             feedbackModal.querySelector('div').classList.remove('scale-100');
             feedbackModal.querySelector('div').classList.add('scale-95');
             setTimeout(() => {
                feedbackModal.classList.add('hidden');
             }, 300);
        }

        function handleNextButton() {
            currentQuestionIndex++;
            if(currentQuestionIndex < questions.length) {
                quizContainer.style.opacity = '0';
                setTimeout(() => {
                    showQuestion();
                    quizContainer.style.opacity = '1';
                }, 300);
            } else {
                showScore();
            }
        }

        function showScore() {
            resetState();
            quizContainer.style.opacity = '0';
            setTimeout(() => {
                const percentage = Math.round((score / questions.length) * 100);
                let message = "";
                if (percentage >= 80) {
                    message = "Excelente desempenho! Você está pronto para a prova!";
                } else if (percentage >= 50) {
                    message = "Bom trabalho! Continue revisando para garantir o sucesso.";
                } else {
                    message = "Não desanime! Use o quiz para revisar os pontos mais difíceis.";
                }

                quizContainer.innerHTML = `
                    <div class="text-center">
                        <h2 class="text-3xl font-bold mb-4 text-cyan-400">Quiz Finalizado!</h2>
                        <p class="text-xl mb-2">Você acertou <span class="font-bold text-green-400">${score}</span> de <span class="font-bold">${questions.length}</span> perguntas.</p>
                        <p class="text-5xl font-bold my-6">${percentage}%</p>
                        <p class="text-lg text-gray-300 mb-8">${message}</p>
                        <button id="restart-btn" class="w-full bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-3 px-6 rounded-lg transition-all duration-300 shadow-lg">Jogar Novamente</button>
                    </div>
                `;
                document.getElementById('restart-btn').addEventListener('click', () => {
                   quizContainer.style.opacity = '0';
                   setTimeout(() => {
                       location.reload();
                   }, 300);
                });
                quizContainer.style.opacity = '1';
            }, 500);
        }

        nextButton.addEventListener('click', () => {
            if(currentQuestionIndex < questions.length) {
                handleNextButton();
            }
        });
        
        closeModalButton.addEventListener('click', () => {
            hideFeedback();
            // Allow user to proceed to next question right after closing modal
            handleNextButton();
        });

        startQuiz();
    </script>
</body>
</html>

